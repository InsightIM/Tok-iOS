// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Message.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MessageRoot

@implementation MessageRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - MessageRoot_FileDescriptor

static GPBFileDescriptor *MessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"im.tox.proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - StrangerGetListReq

@implementation StrangerGetListReq


typedef struct StrangerGetListReq__storage_ {
  uint32_t _has_storage_[1];
} StrangerGetListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StrangerGetListReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(StrangerGetListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Stranger

@implementation Stranger

@dynamic tokId;
@dynamic nickName;
@dynamic bio;
@dynamic signature;
@dynamic avatarFileName;

typedef struct Stranger__storage_ {
  uint32_t _has_storage_[1];
  NSData *tokId;
  NSData *nickName;
  NSData *bio;
  NSData *signature;
  NSData *avatarFileName;
} Stranger__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokId",
        .dataTypeSpecific.className = NULL,
        .number = Stranger_FieldNumber_TokId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Stranger__storage_, tokId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = Stranger_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Stranger__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "bio",
        .dataTypeSpecific.className = NULL,
        .number = Stranger_FieldNumber_Bio,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Stranger__storage_, bio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = Stranger_FieldNumber_Signature,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Stranger__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "avatarFileName",
        .dataTypeSpecific.className = NULL,
        .number = Stranger_FieldNumber_AvatarFileName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Stranger__storage_, avatarFileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Stranger class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Stranger__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StrangerGetListRes

@implementation StrangerGetListRes

@dynamic strangerArray, strangerArray_Count;

typedef struct StrangerGetListRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *strangerArray;
} StrangerGetListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "strangerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Stranger),
        .number = StrangerGetListRes_FieldNumber_StrangerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StrangerGetListRes__storage_, strangerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StrangerGetListRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StrangerGetListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StrangerGetAvatartReq

@implementation StrangerGetAvatartReq

@dynamic pk;

typedef struct StrangerGetAvatartReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *pk;
} StrangerGetAvatartReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pk",
        .dataTypeSpecific.className = NULL,
        .number = StrangerGetAvatartReq_FieldNumber_Pk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StrangerGetAvatartReq__storage_, pk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StrangerGetAvatartReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StrangerGetAvatartReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StrangerSignatureReq

@implementation StrangerSignatureReq

@dynamic pk;

typedef struct StrangerSignatureReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *pk;
} StrangerSignatureReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pk",
        .dataTypeSpecific.className = NULL,
        .number = StrangerSignatureReq_FieldNumber_Pk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StrangerSignatureReq__storage_, pk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StrangerSignatureReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StrangerSignatureReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StrangerSignatureRes

@implementation StrangerSignatureRes

@dynamic pk;
@dynamic signature;

typedef struct StrangerSignatureRes__storage_ {
  uint32_t _has_storage_[1];
  NSData *pk;
  NSData *signature;
} StrangerSignatureRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pk",
        .dataTypeSpecific.className = NULL,
        .number = StrangerSignatureRes_FieldNumber_Pk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StrangerSignatureRes__storage_, pk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = StrangerSignatureRes_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StrangerSignatureRes__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StrangerSignatureRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StrangerSignatureRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryFriendReq

@implementation QueryFriendReq

@dynamic pk;

typedef struct QueryFriendReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *pk;
} QueryFriendReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pk",
        .dataTypeSpecific.className = NULL,
        .number = QueryFriendReq_FieldNumber_Pk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryFriendReq__storage_, pk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryFriendReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryFriendReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryFriendRes

@implementation QueryFriendRes

@dynamic exist;
@dynamic pk;

typedef struct QueryFriendRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t exist;
  NSData *pk;
} QueryFriendRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exist",
        .dataTypeSpecific.className = NULL,
        .number = QueryFriendRes_FieldNumber_Exist,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryFriendRes__storage_, exist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pk",
        .dataTypeSpecific.className = NULL,
        .number = QueryFriendRes_FieldNumber_Pk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QueryFriendRes__storage_, pk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryFriendRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryFriendRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMessageReq

@implementation OfflineMessageReq

@dynamic localMsgId;
@dynamic toPk;
@dynamic cryptoMessage;
@dynamic msgType;

typedef struct OfflineMessageReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t msgType;
  NSData *toPk;
  NSData *cryptoMessage;
  int64_t localMsgId;
} OfflineMessageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "localMsgId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessageReq_FieldNumber_LocalMsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineMessageReq__storage_, localMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "toPk",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessageReq_FieldNumber_ToPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OfflineMessageReq__storage_, toPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cryptoMessage",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessageReq_FieldNumber_CryptoMessage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OfflineMessageReq__storage_, cryptoMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessageReq_FieldNumber_MsgType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OfflineMessageReq__storage_, msgType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMessageReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMessageReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMessageRes

@implementation OfflineMessageRes

@dynamic localMsgId;

typedef struct OfflineMessageRes__storage_ {
  uint32_t _has_storage_[1];
  int64_t localMsgId;
} OfflineMessageRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "localMsgId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessageRes_FieldNumber_LocalMsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineMessageRes__storage_, localMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMessageRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMessageRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMessageReadNotice

@implementation OfflineMessageReadNotice

@dynamic latestMsgId;

typedef struct OfflineMessageReadNotice__storage_ {
  uint32_t _has_storage_[1];
  uint64_t latestMsgId;
} OfflineMessageReadNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latestMsgId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessageReadNotice_FieldNumber_LatestMsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineMessageReadNotice__storage_, latestMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMessageReadNotice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMessageReadNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMessage

@implementation OfflineMessage

@dynamic localMsgId;
@dynamic msgId;
@dynamic frPk;
@dynamic toPk;
@dynamic content;
@dynamic createTime;
@dynamic msgType;
@dynamic fileSize;
@dynamic checksum;
@dynamic fileDisplayName;

typedef struct OfflineMessage__storage_ {
  uint32_t _has_storage_[1];
  uint32_t msgType;
  uint32_t fileSize;
  NSData *frPk;
  NSData *toPk;
  NSData *content;
  NSData *checksum;
  NSData *fileDisplayName;
  int64_t localMsgId;
  uint64_t msgId;
  uint64_t createTime;
} OfflineMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "localMsgId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessage_FieldNumber_LocalMsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineMessage__storage_, localMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessage_FieldNumber_MsgId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OfflineMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "frPk",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessage_FieldNumber_FrPk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OfflineMessage__storage_, frPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toPk",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessage_FieldNumber_ToPk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OfflineMessage__storage_, toPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessage_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OfflineMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessage_FieldNumber_CreateTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OfflineMessage__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessage_FieldNumber_MsgType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OfflineMessage__storage_, msgType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessage_FieldNumber_FileSize,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OfflineMessage__storage_, fileSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "checksum",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessage_FieldNumber_Checksum,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OfflineMessage__storage_, checksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fileDisplayName",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessage_FieldNumber_FileDisplayName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(OfflineMessage__storage_, fileDisplayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMessagePullReq

@implementation OfflineMessagePullReq


typedef struct OfflineMessagePullReq__storage_ {
  uint32_t _has_storage_[1];
} OfflineMessagePullReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMessagePullReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(OfflineMessagePullReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMessagePullRes

@implementation OfflineMessagePullRes

@dynamic msgArray, msgArray_Count;
@dynamic leftCount;

typedef struct OfflineMessagePullRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t leftCount;
  NSMutableArray *msgArray;
} OfflineMessagePullRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OfflineMessage),
        .number = OfflineMessagePullRes_FieldNumber_MsgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OfflineMessagePullRes__storage_, msgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "leftCount",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessagePullRes_FieldNumber_LeftCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineMessagePullRes__storage_, leftCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMessagePullRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMessagePullRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMessageDelReq

@implementation OfflineMessageDelReq

@dynamic lastMsgId;

typedef struct OfflineMessageDelReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t lastMsgId;
} OfflineMessageDelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastMsgId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMessageDelReq_FieldNumber_LastMsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineMessageDelReq__storage_, lastMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMessageDelReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMessageDelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceUpdateReq

@implementation DeviceUpdateReq

@dynamic type;
@dynamic identifier;

typedef struct DeviceUpdateReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  NSData *identifier;
} DeviceUpdateReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = DeviceUpdateReq_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceUpdateReq__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = DeviceUpdateReq_FieldNumber_Identifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceUpdateReq__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceUpdateReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceUpdateReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineFilePullReq

@implementation OfflineFilePullReq

@dynamic msgId;

typedef struct OfflineFilePullReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t msgId;
} OfflineFilePullReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineFilePullReq_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineFilePullReq__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineFilePullReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineFilePullReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineFileCancelReq

@implementation OfflineFileCancelReq

@dynamic msgId;

typedef struct OfflineFileCancelReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t msgId;
} OfflineFileCancelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineFileCancelReq_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineFileCancelReq__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineFileCancelReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineFileCancelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VersionInfoReq

@implementation VersionInfoReq


typedef struct VersionInfoReq__storage_ {
  uint32_t _has_storage_[1];
} VersionInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VersionInfoReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(VersionInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VersionInfoRes

@implementation VersionInfoRes

@dynamic versionCode;
@dynamic version;
@dynamic updateDesc;
@dynamic downloadURL;
@dynamic officialWebsite;
@dynamic remark;

typedef struct VersionInfoRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t versionCode;
  NSData *version;
  NSData *updateDesc;
  NSData *downloadURL;
  NSData *officialWebsite;
  NSData *remark;
} VersionInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "versionCode",
        .dataTypeSpecific.className = NULL,
        .number = VersionInfoRes_FieldNumber_VersionCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VersionInfoRes__storage_, versionCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = VersionInfoRes_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VersionInfoRes__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "updateDesc",
        .dataTypeSpecific.className = NULL,
        .number = VersionInfoRes_FieldNumber_UpdateDesc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VersionInfoRes__storage_, updateDesc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "downloadURL",
        .dataTypeSpecific.className = NULL,
        .number = VersionInfoRes_FieldNumber_DownloadURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VersionInfoRes__storage_, downloadURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "officialWebsite",
        .dataTypeSpecific.className = NULL,
        .number = VersionInfoRes_FieldNumber_OfficialWebsite,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VersionInfoRes__storage_, officialWebsite),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = VersionInfoRes_FieldNumber_Remark,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VersionInfoRes__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VersionInfoRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VersionInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\010\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupCreateReq

@implementation GroupCreateReq

@dynamic groupName;
@dynamic type;

typedef struct GroupCreateReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  NSData *groupName;
} GroupCreateReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateReq_FieldNumber_GroupName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupCreateReq__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateReq_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupCreateReq__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupCreateReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupCreateReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupCreateRes

@implementation GroupCreateRes

@dynamic groupId;
@dynamic groupName;
@dynamic code;

typedef struct GroupCreateRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSData *groupName;
  uint64_t groupId;
} GroupCreateRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateRes_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupCreateRes__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateRes_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupCreateRes__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = GroupCreateRes_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupCreateRes__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupCreateRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupCreateRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInviteReq

@implementation GroupInviteReq

@dynamic groupId;
@dynamic inviterPk;
@dynamic inviteePk;

typedef struct GroupInviteReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *inviterPk;
  NSData *inviteePk;
  uint64_t groupId;
} GroupInviteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInviteReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "inviterPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteReq_FieldNumber_InviterPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInviteReq__storage_, inviterPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "inviteePk",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteReq_FieldNumber_InviteePk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInviteReq__storage_, inviteePk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInviteReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInviteReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInviteNotice

@implementation GroupInviteNotice

@dynamic groupId;
@dynamic inviterPk;
@dynamic inviterName;
@dynamic inviteePk;
@dynamic inviteeName;
@dynamic code;

typedef struct GroupInviteNotice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSData *inviterPk;
  NSData *inviterName;
  NSData *inviteePk;
  NSData *inviteeName;
  uint64_t groupId;
} GroupInviteNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteNotice_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInviteNotice__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "inviterPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteNotice_FieldNumber_InviterPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInviteNotice__storage_, inviterPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "inviterName",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteNotice_FieldNumber_InviterName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInviteNotice__storage_, inviterName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "inviteePk",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteNotice_FieldNumber_InviteePk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupInviteNotice__storage_, inviteePk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "inviteeName",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteNotice_FieldNumber_InviteeName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupInviteNotice__storage_, inviteeName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteNotice_FieldNumber_Code,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupInviteNotice__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInviteNotice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInviteNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupPeerListReq

@implementation GroupPeerListReq

@dynamic groupId;

typedef struct GroupPeerListReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} GroupPeerListReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeerListReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupPeerListReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupPeerListReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupPeerListReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupPeer

@implementation GroupPeer

@dynamic peerPk;
@dynamic peerName;
@dynamic confirmFlag;

typedef struct GroupPeer__storage_ {
  uint32_t _has_storage_[1];
  uint32_t confirmFlag;
  NSData *peerPk;
  NSData *peerName;
} GroupPeer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeer_FieldNumber_PeerPk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupPeer__storage_, peerPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "peerName",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeer_FieldNumber_PeerName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupPeer__storage_, peerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "confirmFlag",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeer_FieldNumber_ConfirmFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupPeer__storage_, confirmFlag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupPeer class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupPeer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupPeerListRes

@implementation GroupPeerListRes

@dynamic groupId;
@dynamic groupName;
@dynamic ownerPk;
@dynamic groupPeerArray, groupPeerArray_Count;

typedef struct GroupPeerListRes__storage_ {
  uint32_t _has_storage_[1];
  NSData *groupName;
  NSData *ownerPk;
  NSMutableArray *groupPeerArray;
  uint64_t groupId;
} GroupPeerListRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeerListRes_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupPeerListRes__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeerListRes_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupPeerListRes__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ownerPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeerListRes_FieldNumber_OwnerPk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupPeerListRes__storage_, ownerPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "groupPeerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupPeer),
        .number = GroupPeerListRes_FieldNumber_GroupPeerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupPeerListRes__storage_, groupPeerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupPeerListRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupPeerListRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupSetTitleReq

@implementation GroupSetTitleReq

@dynamic groupId;
@dynamic groupName;

typedef struct GroupSetTitleReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *groupName;
  uint64_t groupId;
} GroupSetTitleReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupSetTitleReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupSetTitleReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = GroupSetTitleReq_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupSetTitleReq__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupSetTitleReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupSetTitleReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupSetTitleNotice

@implementation GroupSetTitleNotice

@dynamic groupId;
@dynamic groupName;

typedef struct GroupSetTitleNotice__storage_ {
  uint32_t _has_storage_[1];
  NSData *groupName;
  uint64_t groupId;
} GroupSetTitleNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupSetTitleNotice_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupSetTitleNotice__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = GroupSetTitleNotice_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupSetTitleNotice__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupSetTitleNotice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupSetTitleNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupTitleReq

@implementation GroupTitleReq

@dynamic groupId;

typedef struct GroupTitleReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} GroupTitleReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupTitleReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupTitleReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupTitleReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupTitleReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupTitleRes

@implementation GroupTitleRes

@dynamic groupId;
@dynamic groupName;

typedef struct GroupTitleRes__storage_ {
  uint32_t _has_storage_[1];
  NSData *groupName;
  uint64_t groupId;
} GroupTitleRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupTitleRes_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupTitleRes__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = GroupTitleRes_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupTitleRes__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupTitleRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupTitleRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupLeaveReq

@implementation GroupLeaveReq

@dynamic groupId;

typedef struct GroupLeaveReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} GroupLeaveReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupLeaveReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupLeaveReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupLeaveReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupLeaveReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupLeaveNotice

@implementation GroupLeaveNotice

@dynamic groupId;
@dynamic peerPk;
@dynamic peerName;

typedef struct GroupLeaveNotice__storage_ {
  uint32_t _has_storage_[1];
  NSData *peerPk;
  NSData *peerName;
  uint64_t groupId;
} GroupLeaveNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupLeaveNotice_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupLeaveNotice__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "peerPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupLeaveNotice_FieldNumber_PeerPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupLeaveNotice__storage_, peerPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "peerName",
        .dataTypeSpecific.className = NULL,
        .number = GroupLeaveNotice_FieldNumber_PeerName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupLeaveNotice__storage_, peerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupLeaveNotice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupLeaveNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupKickoutReq

@implementation GroupKickoutReq

@dynamic groupId;
@dynamic peerPk;

typedef struct GroupKickoutReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *peerPk;
  uint64_t groupId;
} GroupKickoutReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupKickoutReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupKickoutReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "peerPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupKickoutReq_FieldNumber_PeerPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupKickoutReq__storage_, peerPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupKickoutReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupKickoutReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupKickoutNotice

@implementation GroupKickoutNotice

@dynamic groupId;
@dynamic peerPk;
@dynamic peerName;

typedef struct GroupKickoutNotice__storage_ {
  uint32_t _has_storage_[1];
  NSData *peerPk;
  NSData *peerName;
  uint64_t groupId;
} GroupKickoutNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupKickoutNotice_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupKickoutNotice__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "peerPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupKickoutNotice_FieldNumber_PeerPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupKickoutNotice__storage_, peerPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "peerName",
        .dataTypeSpecific.className = NULL,
        .number = GroupKickoutNotice_FieldNumber_PeerName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupKickoutNotice__storage_, peerName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupKickoutNotice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupKickoutNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupDismissReq

@implementation GroupDismissReq

@dynamic groupId;

typedef struct GroupDismissReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} GroupDismissReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupDismissReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupDismissReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupDismissReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupDismissReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupDismissNotice

@implementation GroupDismissNotice

@dynamic groupId;

typedef struct GroupDismissNotice__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} GroupDismissNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupDismissNotice_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupDismissNotice__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupDismissNotice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupDismissNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMuteReq

@implementation GroupMuteReq

@dynamic groupId;
@dynamic status;

typedef struct GroupMuteReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  uint64_t groupId;
} GroupMuteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMuteReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMuteReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GroupMuteReq_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMuteReq__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMuteReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMuteReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupRealMsg

@implementation GroupRealMsg

@dynamic groupId;
@dynamic msgId;
@dynamic msg;
@dynamic frPk;
@dynamic frName;
@dynamic msgType;
@dynamic fileName;
@dynamic fileDisplayName;
@dynamic createTime;
@dynamic fileSize;
@dynamic checksum;
@dynamic prevMsgId;
@dynamic nextMsgId;

typedef struct GroupRealMsg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t msgType;
  uint32_t fileSize;
  NSData *msg;
  NSData *frPk;
  NSData *frName;
  NSData *fileName;
  NSData *fileDisplayName;
  NSData *checksum;
  uint64_t groupId;
  uint64_t msgId;
  uint64_t createTime;
  uint64_t prevMsgId;
  uint64_t nextMsgId;
} GroupRealMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_MsgId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "frPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_FrPk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, frPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "frName",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_FrName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, frName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_MsgType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, msgType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fileName",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_FileName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, fileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fileDisplayName",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_FileDisplayName,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, fileDisplayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_CreateTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_FileSize,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, fileSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "checksum",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_Checksum,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, checksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prevMsgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_PrevMsgId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, prevMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nextMsgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupRealMsg_FieldNumber_NextMsgId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(GroupRealMsg__storage_, nextMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupRealMsg class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupRealMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMessageReq

@implementation GroupMessageReq

@dynamic groupId;
@dynamic msg;
@dynamic frPk;
@dynamic localMsgId;

typedef struct GroupMessageReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *msg;
  NSData *frPk;
  uint64_t groupId;
  uint64_t localMsgId;
} GroupMessageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMessageReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageReq_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMessageReq__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "frPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageReq_FieldNumber_FrPk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMessageReq__storage_, frPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "localMsgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageReq_FieldNumber_LocalMsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupMessageReq__storage_, localMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMessageReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMessageReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMessageRead

@implementation GroupMessageRead

@dynamic groupId;
@dynamic latestMsgId;
@dynamic leftCount;
@dynamic hasLastMsg, lastMsg;

typedef struct GroupMessageRead__storage_ {
  uint32_t _has_storage_[1];
  uint32_t leftCount;
  GroupRealMsg *lastMsg;
  uint64_t groupId;
  uint64_t latestMsgId;
} GroupMessageRead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageRead_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMessageRead__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "latestMsgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageRead_FieldNumber_LatestMsgId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMessageRead__storage_, latestMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "leftCount",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageRead_FieldNumber_LeftCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMessageRead__storage_, leftCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastMsg",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupRealMsg),
        .number = GroupMessageRead_FieldNumber_LastMsg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupMessageRead__storage_, lastMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMessageRead class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMessageRead__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMessageReadNotice

@implementation GroupMessageReadNotice

@dynamic msgsReadArray, msgsReadArray_Count;

typedef struct GroupMessageReadNotice__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgsReadArray;
} GroupMessageReadNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgsReadArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupMessageRead),
        .number = GroupMessageReadNotice_FieldNumber_MsgsReadArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMessageReadNotice__storage_, msgsReadArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMessageReadNotice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMessageReadNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMessagePullReq

@implementation GroupMessagePullReq

@dynamic groupId;

typedef struct GroupMessagePullReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} GroupMessagePullReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMessagePullReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMessagePullReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMessagePullReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMessagePullRes

@implementation GroupMessagePullRes

@dynamic msgArray, msgArray_Count;
@dynamic groupId;
@dynamic leftCount;

typedef struct GroupMessagePullRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t leftCount;
  NSMutableArray *msgArray;
  uint64_t groupId;
} GroupMessagePullRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupRealMsg),
        .number = GroupMessagePullRes_FieldNumber_MsgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMessagePullRes__storage_, msgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullRes_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMessagePullRes__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "leftCount",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullRes_FieldNumber_LeftCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMessagePullRes__storage_, leftCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMessagePullRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMessagePullRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMessageDelReq

@implementation GroupMessageDelReq

@dynamic groupId;
@dynamic lastMsgId;

typedef struct GroupMessageDelReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
  uint64_t lastMsgId;
} GroupMessageDelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageDelReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMessageDelReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lastMsgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageDelReq_FieldNumber_LastMsgId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMessageDelReq__storage_, lastMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMessageDelReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMessageDelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupErrorNotice

@implementation GroupErrorNotice

@dynamic groupId;
@dynamic code;

typedef struct GroupErrorNotice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  uint64_t groupId;
} GroupErrorNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupErrorNotice_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupErrorNotice__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = GroupErrorNotice_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupErrorNotice__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupErrorNotice class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupErrorNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileTransfer

@implementation FileTransfer

@dynamic groupId;
@dynamic toPk;
@dynamic realName;
@dynamic createTime;
@dynamic frPk;
@dynamic uniqueFileName;
@dynamic content;
@dynamic msgId;
@dynamic code;
@dynamic updateTime;

typedef struct FileTransfer__storage_ {
  uint32_t _has_storage_[1];
  uint32_t code;
  NSData *toPk;
  NSData *realName;
  NSData *frPk;
  NSData *uniqueFileName;
  NSData *content;
  uint64_t groupId;
  uint64_t createTime;
  uint64_t msgId;
  uint64_t updateTime;
} FileTransfer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = FileTransfer_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FileTransfer__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "toPk",
        .dataTypeSpecific.className = NULL,
        .number = FileTransfer_FieldNumber_ToPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FileTransfer__storage_, toPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "realName",
        .dataTypeSpecific.className = NULL,
        .number = FileTransfer_FieldNumber_RealName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FileTransfer__storage_, realName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = FileTransfer_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FileTransfer__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "frPk",
        .dataTypeSpecific.className = NULL,
        .number = FileTransfer_FieldNumber_FrPk,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FileTransfer__storage_, frPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "uniqueFileName",
        .dataTypeSpecific.className = NULL,
        .number = FileTransfer_FieldNumber_UniqueFileName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FileTransfer__storage_, uniqueFileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = FileTransfer_FieldNumber_Content,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FileTransfer__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = FileTransfer_FieldNumber_MsgId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FileTransfer__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = FileTransfer_FieldNumber_Code,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FileTransfer__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.className = NULL,
        .number = FileTransfer_FieldNumber_UpdateTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(FileTransfer__storage_, updateTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FileTransfer class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileTransfer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupFilePullReq

@implementation GroupFilePullReq

@dynamic msgId;
@dynamic groupId;

typedef struct GroupFilePullReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t msgId;
  uint64_t groupId;
} GroupFilePullReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupFilePullReq_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupFilePullReq__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupFilePullReq_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupFilePullReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupFilePullReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupFilePullReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupFileCancelReq

@implementation GroupFileCancelReq

@dynamic msgId;
@dynamic groupId;

typedef struct GroupFileCancelReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t msgId;
  uint64_t groupId;
} GroupFileCancelReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupFileCancelReq_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupFileCancelReq__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupFileCancelReq_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupFileCancelReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupFileCancelReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupFileCancelReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfoReq

@implementation GroupInfoReq

@dynamic groupId;

typedef struct GroupInfoReq__storage_ {
  uint32_t _has_storage_[1];
  uint64_t groupId;
} GroupInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfoReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInfoReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfoRes

@implementation GroupInfoRes

@dynamic groupId;
@dynamic groupName;
@dynamic type;
@dynamic ownerPk;
@dynamic membersNum;
@dynamic remark;
@dynamic shareId;
@dynamic status;

typedef struct GroupInfoRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t membersNum;
  uint32_t status;
  NSData *groupName;
  NSData *ownerPk;
  NSData *remark;
  NSData *shareId;
  uint64_t groupId;
} GroupInfoRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoRes_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfoRes__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoRes_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInfoRes__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoRes_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInfoRes__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ownerPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoRes_FieldNumber_OwnerPk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupInfoRes__storage_, ownerPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "membersNum",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoRes_FieldNumber_MembersNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupInfoRes__storage_, membersNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoRes_FieldNumber_Remark,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupInfoRes__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "shareId",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoRes_FieldNumber_ShareId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GroupInfoRes__storage_, shareId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoRes_FieldNumber_Status,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GroupInfoRes__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInfoRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfoRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupPeerListNewReq

@implementation GroupPeerListNewReq

@dynamic groupId;
@dynamic page;

typedef struct GroupPeerListNewReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t page;
  uint64_t groupId;
} GroupPeerListNewReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeerListNewReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupPeerListNewReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeerListNewReq_FieldNumber_Page,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupPeerListNewReq__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupPeerListNewReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupPeerListNewReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupPeerListNewRes

@implementation GroupPeerListNewRes

@dynamic groupId;
@dynamic groupPeerArray, groupPeerArray_Count;
@dynamic end;

typedef struct GroupPeerListNewRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t end;
  NSMutableArray *groupPeerArray;
  uint64_t groupId;
} GroupPeerListNewRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeerListNewRes_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupPeerListNewRes__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupPeerArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupPeer),
        .number = GroupPeerListNewRes_FieldNumber_GroupPeerArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupPeerListNewRes__storage_, groupPeerArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = GroupPeerListNewRes_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupPeerListNewRes__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupPeerListNewRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupPeerListNewRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupRemarkReq

@implementation GroupRemarkReq

@dynamic groupId;
@dynamic remark;

typedef struct GroupRemarkReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *remark;
  uint64_t groupId;
} GroupRemarkReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupRemarkReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupRemarkReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = GroupRemarkReq_FieldNumber_Remark,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupRemarkReq__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupRemarkReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupRemarkReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupAcceptJoinInfo

@implementation GroupAcceptJoinInfo

@dynamic groupId;
@dynamic inviterPk;
@dynamic groupTitle;
@dynamic groupRemark;

typedef struct GroupAcceptJoinInfo__storage_ {
  uint32_t _has_storage_[1];
  NSData *inviterPk;
  NSData *groupTitle;
  NSData *groupRemark;
  uint64_t groupId;
} GroupAcceptJoinInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupAcceptJoinInfo_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupAcceptJoinInfo__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "inviterPk",
        .dataTypeSpecific.className = NULL,
        .number = GroupAcceptJoinInfo_FieldNumber_InviterPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupAcceptJoinInfo__storage_, inviterPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "groupTitle",
        .dataTypeSpecific.className = NULL,
        .number = GroupAcceptJoinInfo_FieldNumber_GroupTitle,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupAcceptJoinInfo__storage_, groupTitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "groupRemark",
        .dataTypeSpecific.className = NULL,
        .number = GroupAcceptJoinInfo_FieldNumber_GroupRemark,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupAcceptJoinInfo__storage_, groupRemark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupAcceptJoinInfo class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupAcceptJoinInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupAcceptJoinRequest

@implementation GroupAcceptJoinRequest

@dynamic infoArray, infoArray_Count;

typedef struct GroupAcceptJoinRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *infoArray;
} GroupAcceptJoinRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "infoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupAcceptJoinInfo),
        .number = GroupAcceptJoinRequest_FieldNumber_InfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupAcceptJoinRequest__storage_, infoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupAcceptJoinRequest class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupAcceptJoinRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupAcceptJoinResponse

@implementation GroupAcceptJoinResponse

@dynamic groupId;
@dynamic result;

typedef struct GroupAcceptJoinResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t result;
  uint64_t groupId;
} GroupAcceptJoinResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupAcceptJoinResponse_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupAcceptJoinResponse__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = GroupAcceptJoinResponse_FieldNumber_Result,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupAcceptJoinResponse__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupAcceptJoinResponse class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupAcceptJoinResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupRecommendInfo

@implementation GroupRecommendInfo

@dynamic groupId;
@dynamic groupName;
@dynamic membersNum;
@dynamic remark;
@dynamic shareId;

typedef struct GroupRecommendInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t membersNum;
  NSData *groupName;
  NSData *remark;
  NSData *shareId;
  uint64_t groupId;
} GroupRecommendInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupRecommendInfo_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupRecommendInfo__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = GroupRecommendInfo_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupRecommendInfo__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "membersNum",
        .dataTypeSpecific.className = NULL,
        .number = GroupRecommendInfo_FieldNumber_MembersNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupRecommendInfo__storage_, membersNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = GroupRecommendInfo_FieldNumber_Remark,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupRecommendInfo__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "shareId",
        .dataTypeSpecific.className = NULL,
        .number = GroupRecommendInfo_FieldNumber_ShareId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupRecommendInfo__storage_, shareId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupRecommendInfo class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupRecommendInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupRecommendRequest

@implementation GroupRecommendRequest

@dynamic page;

typedef struct GroupRecommendRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t page;
} GroupRecommendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "page",
        .dataTypeSpecific.className = NULL,
        .number = GroupRecommendRequest_FieldNumber_Page,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupRecommendRequest__storage_, page),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupRecommendRequest class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupRecommendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupRecommendResponse

@implementation GroupRecommendResponse

@dynamic infoArray, infoArray_Count;
@dynamic end;

typedef struct GroupRecommendResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t end;
  NSMutableArray *infoArray;
} GroupRecommendResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "infoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupRecommendInfo),
        .number = GroupRecommendResponse_FieldNumber_InfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupRecommendResponse__storage_, infoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = GroupRecommendResponse_FieldNumber_End,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupRecommendResponse__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupRecommendResponse class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupRecommendResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMessagePullNewReq

@implementation GroupMessagePullNewReq

@dynamic groupId;
@dynamic direction;
@dynamic startMsgId;
@dynamic endMsgId;
@dynamic count;
@dynamic tail;

typedef struct GroupMessagePullNewReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t direction;
  uint32_t count;
  uint32_t tail;
  uint64_t groupId;
  uint64_t startMsgId;
  uint64_t endMsgId;
} GroupMessagePullNewReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewReq_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMessagePullNewReq__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "direction",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewReq_FieldNumber_Direction,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMessagePullNewReq__storage_, direction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "startMsgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewReq_FieldNumber_StartMsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMessagePullNewReq__storage_, startMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "endMsgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewReq_FieldNumber_EndMsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupMessagePullNewReq__storage_, endMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewReq_FieldNumber_Count,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupMessagePullNewReq__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tail",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewReq_FieldNumber_Tail,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupMessagePullNewReq__storage_, tail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMessagePullNewReq class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMessagePullNewReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMessagePullNewRes

@implementation GroupMessagePullNewRes

@dynamic msgArray, msgArray_Count;
@dynamic groupId;
@dynamic leftCount;
@dynamic end;
@dynamic direction;
@dynamic tail;
@dynamic startMsgId;
@dynamic endMsgId;

typedef struct GroupMessagePullNewRes__storage_ {
  uint32_t _has_storage_[1];
  uint32_t leftCount;
  uint32_t end;
  uint32_t direction;
  uint32_t tail;
  NSMutableArray *msgArray;
  uint64_t groupId;
  uint64_t startMsgId;
  uint64_t endMsgId;
} GroupMessagePullNewRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupRealMsg),
        .number = GroupMessagePullNewRes_FieldNumber_MsgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupMessagePullNewRes__storage_, msgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewRes_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMessagePullNewRes__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "leftCount",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewRes_FieldNumber_LeftCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMessagePullNewRes__storage_, leftCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewRes_FieldNumber_End,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMessagePullNewRes__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "direction",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewRes_FieldNumber_Direction,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupMessagePullNewRes__storage_, direction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tail",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewRes_FieldNumber_Tail,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupMessagePullNewRes__storage_, tail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "startMsgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewRes_FieldNumber_StartMsgId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupMessagePullNewRes__storage_, startMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "endMsgId",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessagePullNewRes_FieldNumber_EndMsgId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GroupMessagePullNewRes__storage_, endMsgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMessagePullNewRes class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMessagePullNewRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodesFileRequest

@implementation NodesFileRequest

@dynamic hash_p;

typedef struct NodesFileRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
} NodesFileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = NodesFileRequest_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodesFileRequest__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodesFileRequest class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodesFileRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
